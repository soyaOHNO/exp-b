# [3.1 lsq]

def makeAb(w):
  N=w.shape[0]
  A=np.zeros((N*2,8),'d')
  b=np.zeros(N*2,'d')
  i=np.arange(N)
  A[i*2+0,0]=w[i,0]
  A[i*2+0,1]=w[i,1]
  A[i*2+0,2]=1
  A[i*2+0,6]=-w[i,0]*w[i,2]
  A[i*2+0,7]=-w[i,1]*w[i,2]
  A[i*2+1,3]=w[i,0]
  A[i*2+1,4]=w[i,1]
  A[i*2+1,5]=1
  A[i*2+1,6]=-w[i,0]*w[i,3]
  A[i*2+1,7]=-w[i,1]*w[i,3]
  b[i*2    ]=w[i,2]
  b[i*2+1  ]=w[i,3]
  return A,b


def calcHomography(w): # （注）homography = 射影変換

  A,b=makeAb(w) # w から A と b を計算する．

  # LeaST-SQuares = 最小2乗法
  tmp=np.linalg.lstsq(A,b,rcond=None)[0]

  # ※3 tmp の前に 0 個，後ろに 1 個の 1 を追加し，3x3 にする．
  tmp=np.pad(tmp,(0,1),constant_values=1) 
  return tmp.reshape(3,3)



def sumOfSquaredDifference(w, im0, im1):
  for i in range(w.shape[0]):
    W=7
    x,y,u,v=w[i]

    tpl=im0[y-W:y+W+1,
            x-W:x+W+1]
    tgt=im1[v-W:v+W+1,
            u-W:u+W+1]
    res=np.zeros((7,7))
    for dv in range(-3,4):
      for du in range(-3,4):
        tgt=im1[v+dv-W:v+dv+W+1,
                u+du-W:u+du+W+1]
        res[dv+3,du+3]=((tpl-tgt)**2).sum()
    pos = np.array(np.unravel_index(np.argmin(res), res.shape))
    print(f"{i}[v,u] = {pos - [3,3]}")




def main():
  w=np.array([
909,362,598,366,
854,738,556,743,
500,519,178,549,
377,303,19,303,
930,422,618,424,
667,358,366,364,
906,406,596,409,
856,500,553,503,
484,326,154,330,
565,362,253,370,
438,353,97,361,
438,319,97,323,
]).reshape(-1,4)
  H=calcHomography(w)

  dw,dh=1024,768          # 出力画像の大きさ
  im0=eb.getImg('IMG_5565.jpg')  # 入力画像0
  im1=eb.getImg('IMG_5564.jpg')  # 入力画像1


  sumOfSquaredDifference(w,im0,im1)


  m0d=np.array([[ 1,0,-100 ],
                [ 0,1,-100 ],
                [ 0,0,1 ]],'f')                 # 画像0 と 出力画像 の関係

  m1d=H @ m0d                                 # 画像1 と 出力画像 の関係

  dst0=proj(dw,dh, im0, m0d)      # 射影変換後の入力画像0
  dst1=proj(dw,dh, im1, m1d)
  dst=(dst0+dst1)/2               # 画像合成（平均）

  eb.imshow(dst)

----------------------------------------------------------------------------------------------------------------

<bicubic interpolation>
# ディジタル画像処理 p184
def funh(t):
    t = np.abs(t)
    res = np.zeros_like(t, dtype=float)
    m1 = (t <= 1)
    m2 = (t > 1) & (t <= 2)
    res[m1] = np.abs(t[m1]**3) - 2*t[m1]**2 + 1
    res[m2] = -np.abs(t[m2]**3) + 5*t[m2]**2 - 8*t[m2] + 4
    return res

def afn5(dw,dh, src, a):
 im=np.zeros((dh,dw,3),'f')
 y,x=np.mgrid[0:dh,0:dw]
 u,v,w= a[0,0]*x+a[0,1]*y+a[0,2], \
        a[1,0]*x+a[1,1]*y+a[1,2], \
        a[2,0]*x+a[2,1]*y+a[2,2]
 u,v=u/w,v/w
 m = (0<=u)&(u+1<src.shape[1])&(0<=v)&(v+1<src.shape[0])
 ium=np.floor(u[m]); fum=(u[m]-ium)[...,None]; ium=ium.astype('i')
 ivm=np.floor(v[m]); fvm=(v[m]-ivm)[...,None]; ivm=ivm.astype('i')
 x1,x2,x3,x4=1+fum,fum,1-fum,2-fum
 y1,y2,y3,y4=1+fvm,fvm,1-fvm,2-fvm
 # I(x,y)=hx @ fij @ hy
 im[y[m],x[m]]=src[ivm-1,ium-1]*funh(y1)*funh(x1)+ \
               src[ivm  ,ium-1]*funh(y2)*funh(x1)+ \
               src[ivm+1,ium-1]*funh(y3)*funh(x1)+ \
               src[ivm+2,ium-1]*funh(y4)*funh(x1)+ \
               src[ivm-1,ium  ]*funh(y1)*funh(x2)+ \
               src[ivm  ,ium  ]*funh(y2)*funh(x2)+ \
               src[ivm+1,ium  ]*funh(y3)*funh(x2)+ \
               src[ivm+2,ium  ]*funh(y4)*funh(x2)+ \
               src[ivm-1,ium+1]*funh(y1)*funh(x3)+ \
               src[ivm  ,ium+1]*funh(y2)*funh(x3)+ \
               src[ivm+1,ium+1]*funh(y3)*funh(x3)+ \
               src[ivm+2,ium+1]*funh(y4)*funh(x3)+ \
               src[ivm-1,ium+2]*funh(y1)*funh(x4)+ \
               src[ivm  ,ium+2]*funh(y2)*funh(x4)+ \
               src[ivm+1,ium+2]*funh(y3)*funh(x4)+ \
               src[ivm+2,ium+2]*funh(y4)*funh(x4)
 return im



バイリニア補間は位置(x,y)の値I(x,y)を求めるにあたって，周辺の画素値src[ivm+a,ium+b] (a=0or1,b=0or1)の値を使用する．
行方向に対して線形補間を行ったのちに列方向に対して線形補間を行うことによってIを得る(逆も然り)．
バイキュービック補間は補間に使用する画素値が周辺16箇所に対して行うようにしたものである．これは行列で簡単に表すことができる．
$f_{ij}$は入力画像の位置(i,j)における画素値で，$h(t)$はsinc関数である．今回はsinc関数の表現に
\begin{equation}
    h(t) = 
        \begin{cases}
            |t|^3-2|t|^2+1 & (|t| \geqq 1) \\
            -|t|^3+5|t|^2-8|t|+4 & (1 < |t| \geqq 2) \\
            0        & (2 < |t|)
        \end{cases}
\end{equation}
という式を使用している．
これらから$I(x,y)$を表現すると，
\[
I(x,y)=
\begin{pmatrix}
    h(x_1) & h(x_2) & h(x_3) & h(x_4)
\end{pmatrix}
\begin{pmatrix}
    f_{11} & f_{12} & f_{13} & f_{14} \\
    f_{21} & f_{22} & f_{23} & f_{24} \\
    f_{31} & f_{32} & f_{33} & f_{34} \\
    f_{41} & f_{42} & f_{43} & f_{44} \\
\end{pmatrix}
\begin{pmatrix}
    h(y_1) & h(y_2) & h(y_3) & h(y_4)
\end{pmatrix}
\]
となる．ただし，
\begin{align}
  &x_1 = 1 + x - [x] \\
  &x_2 = x - [x] \\
  &x_3 = 1 - (x - [x]) \\
  &x_4 = 2 - (x - [x]) \\
  &y_1 = 1 + x - [x] \\
  &y_2 = x - [x] \\
  &y_3 = 1 - (x - [x]) \\
  &y_4 = 2 - (x - [x]) \\
\end{align}
([a]はフロアを表している．)と定義している．

今回のコードでは，展開した式で扱っている．

----------------------------------------------------------------------------------------------------------------


